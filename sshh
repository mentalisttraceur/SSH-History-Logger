#!/bin/sh
# SSH History Logger 1.0.6
# Copyright (C) Alexander Kozhevnikov <mentalisttraceur@gmail.com> 2015-06-05;
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public Licence as published by
# the Free Software Foundation, either version 3 of the licence or,
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for details.
# 
# You should've received a copy of the GNU General Public License
# with this program. If not, see <http://www.gnu.org/licences/>,
# or write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330 Boston MA 02111-1307 USA.

# On 2015-09-07, this script was compatible with Bourne and POSIX shells.
# EXCEPT for the following exceptions:
# Function declarations (First appeared in SVR2 Bourne shells in 1984).

logdir=~/.ssh_history

case $ZSH_VERSION in ?*) alias -g '${1+"$@"}="$@"'; esac

# Create the folder with user-only read+search permissions if it doesn't exist.
mkdir -m 700 -p "$logdir" || exit 1

# ISO8601 allows for time to be specified with or without colons. But MSDOS and
# Windows ruined it for everyone (to this day exFAT, a common filesystem on USB
# drives, SD cards, etc, does not support colons in filenames), so support for
# colons in filenames is limited in the wild. Therefore, going with the
# no-colon option.
timestamp=`date -Is | sed s/://g`

# Create logfile, fail if unable to do so, since that defeats the whole point
# of this script.
logfile=`mktemp "$logdir"/"$timestamp"_"$*"_XXXXXX` || exit 2

# Set up the logging part of the pipeline through which the SSH command output
# is ran, depending on what commands are available.
if command -v vee 1>/dev/null 2>&1
then
 # If we have vee, then we can split the output into two that way.
 logger()
 {
  vee -i 1 4 > "$logfile"
 }
# We could add other "better" but less portable things, like /dev/fd usage, in
# here, in elif clauses.
else
 # If we don't have vee, the next portable way is to use a named pipe.
 logpipe=$logfile.pipe
 if mkfifo -m 600 "$logpipe"
 then
  logger()
  {
   # If we succesfully made the pipe, then we utilize it along with tee here.
   cat "$logpipe" > "$logfile" &
   tee -i "$logpipe" 1>&4
   rm "$logpipe"
  }
 else
  logger()
  {
   # If we failed to make the pipe, we print a warning, then "gracefully" drop
   # the log-modifying functionality, and just log it with tee directly to the
   # logfile "raw".
   tee -i "$logfile" 1>&4
  }
 fi
fi

exec 4>&1
exitcode=`
{
 {
  ssh ${1+"$@"} 3>&-
  printf $? 1>&3
 } 4>&- | logger
} 3>&1`
exec 4>&-

exit $exitcode
